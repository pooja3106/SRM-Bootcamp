RAT IN A MAZE 

public class Main
{
    
    private boolean dfs(int[][]m, int x ,int y,int n){
        
        //if destination is reached 
        if(x == n-1 && y == n - 1){
            return true;
        }
        
        // if the cell is blocked or already reached
        if(m[x][y] == 0) return false;
        
        //mark the cell is visited
        m[x][y] = 0;
        
        //logic 
        boolean found = false;
        
        //move to the up
        if(x > 0){
            found = dfs(m,x - 1, y ,n );
        }
        
        //move to the down
        if(! found && x < n-1) {
            found = dfs(m , x + 1, y ,n );
        }
        
        //move to the left
        if(! found && y > 0){
            found = dfs(m,x,y- 1 ,n );
        }
        
        //move to the right
        if(! found && y < n - 1){
            found = dfs(m,x, y + 1 ,n );
        }
        
        //backtracking
        //used for making a cell unmarked or unvisited
        m[x][y] =1;
        
        return found;
    }
    
    public boolean canReachDestination(int[][] grid){
        int n = grid.length;
        
        //if starting or ending position is blocked 
        //then i can't reach to the destination
        if(grid[0][0] == 0|| grid[n - 1][n - 1] == 0){
            return false;
        }
        return dfs(grid , 0 ,0 ,n);
        
    }
	public static void main(String[] args) {
	    Main main = new Main();
	    
	    int[][] grid = {
	        {1,0,0,0},
	        {1,1,0,1},
	        {1,1,0,0},
	        {0,1,1,1}
	    };
		System.out.println(main.canReachDestination(grid));
	}
}

IN HOW MANY WAYS WE CAN REACH THE DESTINATION?

public class Main
{
    
    private int dfs(int[][]m, int x ,int y,int n){
        
        //if destination is reached 
        if(x == n-1 && y == n - 1){
            return 1;
        }
        
        // if the cell is blocked or already reached
        if(m[x][y] == 0) return 0;
        
        //mark the cell is visited
        m[x][y] = 0;
        
        //logic 
        int totalPath = 0;
        
        //move to the up
        if(x > 0){
            totalPath += dfs(m,x - 1, y ,n );
        }
        
        //move to the down
        if( x < n-1) {
            totalPath += dfs(m , x + 1, y ,n );
        }
        
        //move to the left
        if( y > 0){
            totalPath += dfs(m,x,y- 1 ,n );
        }
        
        //move to the right
        if( y < n - 1){
            totalPath += dfs(m,x, y + 1 ,n );
        }
        
        //backtracking
        //used for making a cell unmarked or unvisited
        m[x][y] =1;
        
        return totalPath;
    }
    
    public int canReachDestination(int[][] grid){
        int n = grid.length;
        
        //if starting or ending position is blocked 
        //then i can't reach to the destination
        if(grid[0][0] == 0|| grid[n - 1][n - 1] == 0){
            return 0;
        }
        return dfs(grid , 0 ,0 ,n);
        
    }
	public static void main(String[] args) {
	    Main main = new Main();
	    
	    int[][] grid = {
	        {1,0,0,0},
	        {1,1,0,1},
	        {1,1,0,0},
	        {0,1,1,1}
	    };
		System.out.println(main.canReachDestination(grid));
	}
}
